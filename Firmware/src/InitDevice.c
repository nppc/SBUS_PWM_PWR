//#pragma src
//=========================================================
// src/InitDevice.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include "main.h"
#include "InitDevice.h"


extern void enter_DefaultMode_from_RESET(void) {
	WDT_0_enter_DefaultMode_from_RESET(); //SFR PAGE=0x00
	PORTS_0_enter_DefaultMode_from_RESET(); //SFR PAGE=0x00
	PORTS_1_enter_DefaultMode_from_RESET(); //SFR PAGE=0x00
	PBCFG_0_enter_DefaultMode_from_RESET(); //SFR PAGE=0x00
	CIP51_0_enter_DefaultMode_from_RESET(); //SFR PAGE=0x10
	CLOCK_0_enter_DefaultMode_from_RESET(); //SFR PAGE=0x00
	PCA_0_enter_DefaultMode_from_RESET(); //SFR PAGE=0x00
	PCACH_0_enter_DefaultMode_from_RESET(); //SFR PAGE=0x00
	PCACH_1_enter_DefaultMode_from_RESET(); //SFR PAGE=0x00
	UARTE_1_enter_DefaultMode_from_RESET (); //SFR PAGE=0x20
	CLU_0_enter_DefaultMode_from_RESET(); //SFR PAGE=0x20
	CLU_1_enter_DefaultMode_from_RESET (); //SFR PAGE=0x20
  CL_0_enter_DefaultMode_from_RESET (); //SFR PAGE=0x20
  CMP_1_enter_DefaultMode_from_RESET (); //SFR PAGE=0x30
  ADC_0_enter_DefaultMode_from_RESET (); //SFR PAGE=0x30
  PWM_0_enter_DefaultMode_from_RESET (); //SFR PAGE=0x10
  TIMER16_2_enter_DefaultMode_from_RESET(); //SFR PAGE=0x10
  TIMER16_3_enter_DefaultMode_from_RESET(); //SFR PAGE=0x10
  INTERRUPT_0_enter_DefaultMode_from_RESET(); //SFR PAGE=0x00

}

extern void WDT_0_enter_DefaultMode_from_RESET(void) {
	// $[Watchdog Timer Init Variable Declarations]
	uint32_t i;
	bool ea;
	// [Watchdog Timer Init Variable Declarations]$

	// $[WDTCN - Watchdog Timer Control]
	// Deprecated
	// [WDTCN - Watchdog Timer Control]$

	// $[WDTCN_2 - Watchdog Timer Control]
	SFRPAGE = 0x00;

	// Feed WDT timer before disabling (Erratum WDT_E102)
	WDTCN = 0xA5;

	// Add 2 LFO cycle delay before disabling WDT (Erratum WDT_E102)
	for (i = 0; i < (2 * 3062500UL) / (80000 * 3); i++) {
		NOP();
	}

	// Disable WDT
	ea = IE_EA;
	IE_EA = 0;
	WDTCN = 0xDE;
	WDTCN = 0xAD;
	IE_EA = ea;

	// [WDTCN_2 - Watchdog Timer Control]$

}

extern void PORTS_0_enter_DefaultMode_from_RESET(void) {

	P0MDOUT = P0MDOUT_B0__OPEN_DRAIN
	        | P0MDOUT_B1__OPEN_DRAIN
	        | P0MDOUT_B2__OPEN_DRAIN
	        | P0MDOUT_B3__OPEN_DRAIN
	        | P0MDOUT_B4__OPEN_DRAIN
	        | P0MDOUT_B5__OPEN_DRAIN
	        | P0MDOUT_B6__PUSH_PULL
	        | P0MDOUT_B7__OPEN_DRAIN;

	P0MDIN = P0MDIN_B0__DIGITAL
	       | P0MDIN_B1__DIGITAL
	       | P0MDIN_B2__DIGITAL
	       | P0MDIN_B3__DIGITAL
	       | P0MDIN_B4__DIGITAL
	       | P0MDIN_B5__DIGITAL
	       | P0MDIN_B6__DIGITAL
	       | P0MDIN_B7__DIGITAL;

	P0SKIP = P0SKIP_B0__SKIPPED
	       | P0SKIP_B1__SKIPPED
	       | P0SKIP_B2__NOT_SKIPPED
	       | P0SKIP_B3__SKIPPED
	       | P0SKIP_B4__NOT_SKIPPED
	       | P0SKIP_B5__SKIPPED
	       | P0SKIP_B6__NOT_SKIPPED
	       | P0SKIP_B7__NOT_SKIPPED;

}

extern void PORTS_1_enter_DefaultMode_from_RESET(void) {

  //PIN_BUTB = 0;

  P1MDOUT = P1MDOUT_B0__OPEN_DRAIN
          | P1MDOUT_B1__OPEN_DRAIN
          | P1MDOUT_B2__OPEN_DRAIN
          | P1MDOUT_B3__OPEN_DRAIN
          | P1MDOUT_B4__OPEN_DRAIN
          | P1MDOUT_B5__OPEN_DRAIN
          | P1MDOUT_B6__OPEN_DRAIN;

	P1MDIN = P1MDIN_B0__DIGITAL
	       | P1MDIN_B1__DIGITAL
	       | P1MDIN_B2__DIGITAL
	       | P1MDIN_B3__ANALOG
	       | P1MDIN_B4__DIGITAL
	       | P1MDIN_B5__DIGITAL
	       | P1MDIN_B6__DIGITAL;

	P1SKIP = P1SKIP_B0__SKIPPED
	       | P1SKIP_B1__SKIPPED
	       | P1SKIP_B2__SKIPPED
	       | P1SKIP_B3__SKIPPED
	       | P1SKIP_B4__NOT_SKIPPED
	       | P1SKIP_B5__NOT_SKIPPED
	       | P1SKIP_B6__NOT_SKIPPED;

}

extern void PBCFG_0_enter_DefaultMode_from_RESET(void) {
	XBR1 = XBR1_PCA0ME__CEX0_TO_CEX1;

	XBR2 = XBR2_WEAKPUD__PULL_UPS_ENABLED
	     | XBR2_XBARE__ENABLED
	     | XBR2_PWME__PWM0CH01
	     | XBR2_URT1E__ENABLED;

}

extern void CLOCK_0_enter_DefaultMode_from_RESET(void) {
	// $[HFOSC1 Setup]
	// Ensure SYSCLK is > 24 MHz before switching to HFOSC1
	SFRPAGE = 0x00;
  CLKSEL = CLKSEL_CLKSL__HFOSC0_clk24p5 | CLKSEL_CLKDIV__SYSCLK_DIV_1;
	while ((CLKSEL & CLKSEL_DIVRDY__BMASK) == CLKSEL_DIVRDY__NOT_READY)
		;
	// [HFOSC1 Setup]$

	// $[CLKSEL - Clock Select]
	/***********************************************************************
	 - Clock derived from the Internal High Frequency Oscillator 1
	 - SYSCLK is equal to selected clock source divided by 1
	 ***********************************************************************/
  CLKSEL = CLKSEL_CLKSL__HFOSC0_clk49 | CLKSEL_CLKDIV__SYSCLK_DIV_1;
	while ((CLKSEL & CLKSEL_DIVRDY__BMASK) == CLKSEL_DIVRDY__NOT_READY)
		;
	// [CLKSEL - Clock Select]$

}

extern void PCA_0_enter_DefaultMode_from_RESET(void) {
	// $[PCA Off]
	PCA0CN0_CR = PCA0CN0_CR__STOP;
	// [PCA Off]$

	 /***********************************************************************
	   - PCA continues to function normally while the system controller is in
	   Idle Mode
	   - Disable the CF interrupt
	   - System clock divided by 4
	   ***********************************************************************/
	  PCA0MD = PCA0MD_CIDL__NORMAL | PCA0MD_ECF__OVF_INT_DISABLED
	      | PCA0MD_CPS__SYSCLK_DIV_4;

	// PCA Center Alignment Enable
	  PCA0CENT = PCA0CENT_CEX0CEN__CENTER | PCA0CENT_CEX1CEN__CENTER;


	// PCA Output Polarity (start with non inverted to get high outputs)
	//PCA0POL = PCA0POL_CEX0POL__INVERT | PCA0POL_CEX1POL__INVERT;

	PCA0CN0_CR = PCA0CN0_CR__RUN;

}

extern void PCACH_0_enter_DefaultMode_from_RESET(void) {
  // $[PCA0 Settings Save]
  // Select Capture/Compare register)
  PCA0PWM &= ~PCA0PWM_ARSEL__BMASK;
  // [PCA0 Settings Save]$

  // $[PCA0CPM0 - PCA Channel 0 Capture/Compare Mode]
  /***********************************************************************
   - Disable negative edge capture
   - Enable a Capture/Compare Flag interrupt request when CCF0 is set
   - Enable match function
   - 16-bit PWM selected
   - Disable positive edge capture
   - Enable comparator function
   - Enable PWM function
   - Disable toggle function
   ***********************************************************************/
  PCA0CPM0 = PCA0CPM0_CAPN__DISABLED | PCA0CPM0_ECCF__ENABLED
      | PCA0CPM0_MAT__ENABLED | PCA0CPM0_PWM16__16_BIT
      | PCA0CPM0_CAPP__DISABLED | PCA0CPM0_ECOM__ENABLED | PCA0CPM0_PWM__ENABLED
      | PCA0CPM0_TOG__DISABLED;
  // [PCA0CPM0 - PCA Channel 0 Capture/Compare Mode]$

  // $[PCA0CPL0 - PCA Channel 0 Capture Module Low Byte]
  // [PCA0CPL0 - PCA Channel 0 Capture Module Low Byte]$

  // $[PCA0CPH0 - PCA Channel 0 Capture Module High Byte]
  PCA0CPH0 = 0x00;
  // [PCA0CPH0 - PCA Channel 0 Capture Module High Byte]$

  // $[Auto-reload]
  // [Auto-reload]$

  // $[PCA0 Settings Restore]
  // [PCA0 Settings Restore]$

}

extern void PCACH_1_enter_DefaultMode_from_RESET(void) {
  // $[PCA0 Settings Save]
  // Select Capture/Compare register)
  PCA0PWM &= ~PCA0PWM_ARSEL__BMASK;
  // [PCA0 Settings Save]$

  // $[PCA0CPM0 - PCA Channel 0 Capture/Compare Mode]
  /***********************************************************************
   - Disable negative edge capture
   - Enable a Capture/Compare Flag interrupt request when CCF0 is set
   - Enable match function
   - 16-bit PWM selected
   - Disable positive edge capture
   - Enable comparator function
   - Enable PWM function
   - Disable toggle function
   ***********************************************************************/
  PCA0CPM1 = PCA0CPM1_CAPN__DISABLED | PCA0CPM1_ECCF__ENABLED
      | PCA0CPM1_MAT__ENABLED | PCA0CPM1_PWM16__16_BIT
      | PCA0CPM1_CAPP__DISABLED | PCA0CPM1_ECOM__ENABLED | PCA0CPM1_PWM__ENABLED
      | PCA0CPM1_TOG__DISABLED;
  // [PCA0CPM0 - PCA Channel 0 Capture/Compare Mode]$

  // $[PCA0CPL0 - PCA Channel 0 Capture Module Low Byte]
  // [PCA0CPL0 - PCA Channel 0 Capture Module Low Byte]$

  // $[PCA0CPH0 - PCA Channel 0 Capture Module High Byte]
  PCA0CPH1 = 0x00;
  // [PCA0CPH0 - PCA Channel 0 Capture Module High Byte]$

  // $[Auto-reload]
  // [Auto-reload]$

  // $[PCA0 Settings Restore]
  // [PCA0 Settings Restore]$

}


extern void INTERRUPT_0_enter_DefaultMode_from_RESET(void) {
  SFRPAGE = 0x00;

  // $[EIE1 - Extended Interrupt Enable 1]
	/***********************************************************************
	 - Disable ADC0 Conversion Complete interrupt
	 - Disable ADC0 Window Comparison interrupt
	 - Disable CP0 interrupts
	 - Disable CP1 interrupts
	 - Disable interrupt requests generated by a Port Match
	 - Enable interrupt requests generated by PCA0
	 - Disable all SMB0 interrupts
	 - Enable Timer 3 interrupts
	 ***********************************************************************/
	EIE1 = EIE1_EADC0__DISABLED | EIE1_EWADC0__DISABLED | EIE1_ECP0__DISABLED
			| EIE1_ECP1__DISABLED | EIE1_EMAT__DISABLED | EIE1_EPCA0__ENABLED
			| EIE1_ESMB0__DISABLED | EIE1_ET3__ENABLED;
	// [EIE1 - Extended Interrupt Enable 1]$

	EIE2 = EIE2_EPWM0__ENABLED | EIE2_ES1__ENABLED; // UART1 interrupt

	/***********************************************************************
	 - Disable each interrupt according to its individual mask setting
	 - Disable external interrupt 0
	 - Disable external interrupt 1
	 - Disable all SPI0 interrupts
	 - Disable all Timer 0 interrupt
	 - Disable all Timer 1 interrupt
	 - Enable interrupt requests generated by the TF2L or TF2H flags
	 - Disable UART0 interrupt
	 ***********************************************************************/
	IE = IE_EA__DISABLED | IE_EX0__DISABLED | IE_EX1__DISABLED
			| IE_ESPI0__DISABLED | IE_ET0__DISABLED | IE_ET1__DISABLED
			| IE_ET2__ENABLED | IE_ES0__DISABLED;

	// $[IP - Interrupt Priority]
	// [IP - Interrupt Priority]$

	// $[IPH - Interrupt Priority High]
	// [IPH - Interrupt Priority High]$

}



extern void CIP51_0_enter_DefaultMode_from_RESET(void) {
	// $[PFE0CN - Prefetch Engine Control]
	/***********************************************************************
	 - Enable the prefetch engine 
	 - SYSCLK < 50 MHz
	 ***********************************************************************/
	SFRPAGE = 0x10;
	PFE0CN = PFE0CN_FLRT__SYSCLK_BELOW_50_MHZ;
	// [PFE0CN - Prefetch Engine Control]$

}


extern void UARTE_1_enter_DefaultMode_from_RESET (void)
{
  // $[SBCON1 - UART1 Baud Rate Generator Control]
  /***********************************************************************
   - Enable the baud rate generator
   - Prescaler = 1
   ***********************************************************************/
  SFRPAGE = 0x20;
  SBCON1 = SBCON1_BREN__ENABLED | SBCON1_BPS__DIV_BY_1;
  // [SBCON1 - UART1 Baud Rate Generator Control]$

  // $[SMOD1 - UART1 Mode]
  /***********************************************************************
   - 8 bits
   - Enable hardware parity
   - Disable the extra bit
   - Even
   - Long: Stop bit is active for two bit times
   - RI will be activated after the data is received
   ***********************************************************************/
  SMOD1 = SMOD1_SDL__8_BITS | SMOD1_PE__PARITY_ENABLED | SMOD1_XBE__DISABLED
      | SMOD1_SPT__EVEN_PARITY | SMOD1_SBL__LONG | SMOD1_MCE__MULTI_DISABLED;
  // [SMOD1 - UART1 Mode]$

  UART1PCF = UART1PCF_RXSEL__CLU1; // RX routed to CLU1.out

  // $[SBRLH1 - UART1 Baud Rate Generator High Byte]
  /***********************************************************************
   - UART1 Baud Rate Reload High = 0xFF
   ***********************************************************************/
  SBRLH1 = (0xFF << SBRLH1_BRH__SHIFT);
  // [SBRLH1 - UART1 Baud Rate Generator High Byte]$

  // $[SBRLL1 - UART1 Baud Rate Generator Low Byte]
  /***********************************************************************
   - UART1 Baud Rate Reload Low = 0x0B
   ***********************************************************************/
  SBRLL1 = (0x0B << SBRLL1_BRL__SHIFT);
  // [SBRLL1 - UART1 Baud Rate Generator Low Byte]$

  // $[UART1LIN - UART1 LIN Configuration]
  // [UART1LIN - UART1 LIN Configuration]$

  // $[SCON1 - UART1 Serial Port Control]
  /***********************************************************************
   - UART1 reception enabled
   ***********************************************************************/

  SCON1 |= SCON1_REN__RECEIVE_ENABLED;
  // [SCON1 - UART1 Serial Port Control]$

  UART1FCN1_RIE = 1; // Receive interrupt

}

extern void CLU_0_enter_DefaultMode_from_RESET (void)
{
  // $[CLU0FN - Configurable Logic Unit 0 Function Select]
  /***********************************************************************
   - CLU Look-Up-Table function select = 0xF0
   ***********************************************************************/
  CLU0FN = (0xF0 << CLU0FN_FNSEL__SHIFT);
  // [CLU0FN - Configurable Logic Unit 0 Function Select]$

  // $[CLU0MX - Configurable Logic Unit 0 Multiplexer]
  /***********************************************************************
   - Select CLU0A.12
   - Select CLU0B.0
   ***********************************************************************/
  CLU0MX = CLU0MX_MXA__CLU0A12 | CLU0MX_MXB__CLU0B0;
  // [CLU0MX - Configurable Logic Unit 0 Multiplexer]$

  // $[CLU0CF - Configurable Logic Unit 0 Configuration]
  /***********************************************************************
   - Select LUT output
   ***********************************************************************/
  CLU0CF |= CLU0CF_OUTSEL__LUT;
  // [CLU0CF - Configurable Logic Unit 0 Configuration]$

}

extern void CLU_1_enter_DefaultMode_from_RESET (void)
{
  // $[CLU1FN - Configurable Logic Unit 1 Function Select]
  /***********************************************************************
   - CLU Look-Up-Table function select = 0x0F
   ***********************************************************************/
  CLU1FN = (0x0F << CLU1FN_FNSEL__SHIFT);
  // [CLU1FN - Configurable Logic Unit 1 Function Select]$

  // $[CLU1MX - Configurable Logic Unit 1 Multiplexer]
  /***********************************************************************
   - Select CLU1A.10
   - Select CLU1B.0
   ***********************************************************************/
  CLU1MX = CLU1MX_MXA__CLU1A10 | CLU1MX_MXB__CLU1B0;
  // [CLU1MX - Configurable Logic Unit 1 Multiplexer]$

  // $[CLU1CF - Configurable Logic Unit 1 Configuration]
  /***********************************************************************
   - Select LUT output
   ***********************************************************************/
  CLU1CF = CLU1CF_OUTSEL__LUT;// | CLU1CF_OEN__ENABLE;
  // [CLU1CF - Configurable Logic Unit 1 Configuration]$


}

extern void CL_0_enter_DefaultMode_from_RESET (void)
{
  /***********************************************************************
   - CLU0 is enabled
   - CLU1 is enabled
   - CLU2 is disabled. The output of the block will be logic low
   - CLU3 is disabled. The output of the block will be logic low
   ***********************************************************************/
  CLEN0 = CLEN0_C0EN__ENABLE | CLEN0_C1EN__ENABLE | CLEN0_C2EN__DISABLE
      | CLEN0_C3EN__DISABLE;

}

extern void PWM_0_enter_DefaultMode_from_RESET (void)
{
  SFRPAGE = 0x10;
  PWMCFG0 = PWMCFG0_PWMMODE__EDGE | PWMCFG0_PWMCLKEN__ENABLE | PWMCFG0_SYNCUPD__CH0CH1;
  PWMCFG2 = PWMCFG2_CH0EN__ENABLE | PWMCFG2_CH1EN__ENABLE | PWMCFG2_CNTRZERO__ZERO;
  PWMCKDIV = 3; // divide SYSCLK by 8
  PWMLIML = 0xFF;
  PWMLIMH = 0xFF;
  PWMIE = PWMIE_CTROVIE__ENABLE; // Enable overflow interrupt
  PWMCFG1 = PWMCFG1_PWMLTSYS__LTSYSCK | PWMCFG1_PWMEN__ENABLE; // start PWM0

}

extern void TIMER16_2_enter_DefaultMode_from_RESET (void)
{
  TMR2CN1 = TMR2CN1_RLFSEL__CLU0_OUT; // force reload from CLU0.out

  /***********************************************************************
   - Timer 2 Reload value for 3ms overflows
   ***********************************************************************/
  TMR2RLH = (0xF0 << TMR2RLH_TMR2RLH__SHIFT);
  TMR2RLL = (0x0D << TMR2RLL_TMR2RLL__SHIFT);

  TMR2CN0 |= TMR2CN0_TR2__RUN;

}

extern void TIMER16_3_enter_DefaultMode_from_RESET (void)
{
  TMR3CN0 |= TMR3CN0_TR3__RUN;
}

extern void CMP_1_enter_DefaultMode_from_RESET(void)
{
  SFRPAGE = 0x30;
  CMP1MX = CMP1MX_CMXP__CMP1P1 | CMP1MX_CMXN__CMP1N11;
  CMP1CN1 = CMP1CN1_DACEN__ENABLED | 14;
  CMP1CN0 = CMP1CN0_CPEN__ENABLED;

}

extern void ADC_0_enter_DefaultMode_from_RESET (void)
{
  CLKGRP0 |= CLKGRP0_EN_CPCLK__ENABLE | CLKGRP0_CLKDIVSL__DIV2;
  CLKGRP0 |= CLKGRP0_EN_SARCLK__ENABLE;

  ADC0CN2 = ADC0CN2_VDDDIV_INP__VDD_DIV;

  // - Conversion Tracking Time = 0x18
  // 400ns minimum
  // Tadtk = ADTK / (Fsarclk)
  ADC0CF1 = (0x18 << ADC0CF1_ADTK__SHIFT);

  ADC0CF2 = ADC0CF2_REFSL__1V2;

  ADC0MX = ADC0MX_ADC0MX__VDD_DIV;

  ADC0CN0 |= ADC0CN0_ADEN__ENABLED;

}

